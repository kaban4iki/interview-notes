---
{"dg-publish":true,"permalink":"/interview/knowlage-base/concurrency-and-distributed-systems/async-io-and-synchronization/"}
---

## Асинхронная модель Python

**Кратко:**  
AsyncIO реализует кооперативную многозадачность в одном потоке.  
Задачи добровольно отдают управление в точках `await`.

**Типовой вопрос:**  
В чём принципиальное отличие async от потоков?

**Ответ:**  
Async:
- не использует вытеснение
- переключается только в `await`
- требует неблокирующего кода

Потоки переключаются планировщиком ОС и требуют синхронизации.

---

## Event Loop

**Кратко:**  
Event loop — центральный механизм async-системы.  
Он управляет:
- задачами
- ожиданием I/O
- таймерами
- обратными вызовами

**Типовой вопрос:**  
Почему в процессе может быть только один активный event loop?

**Ответ:**  
Потому что:
- loop управляет всеми async-операциями
- несколько loop в одном потоке нарушают модель исполнения

Обычно: один loop на процесс.

---

## Coroutine, Task, Future

**Кратко:**  
- Coroutine — описание асинхронной операции  
- Task — запланированная coroutine  
- Future — объект результата, доступного позже  

**Типовой вопрос:**  
Зачем нужен Task, если есть coroutine?

**Ответ:**  
Task:
- управляется event loop
- выполняется конкурентно
- может быть отменён или ожидаться

Coroutine без Task не исполняется.

---

## await

**Кратко:**  
`await` — единственная точка, где управление возвращается event loop.

**Типовой вопрос:**  
Почему blocking-код внутри async функции опасен?

**Ответ:**  
Потому что:
- блокируется весь event loop
- останавливаются все задачи
- latency растёт нелинейно

В async-коде допустим только неблокирующий I/O.

---

## Cancellation

**Кратко:**  
Отмена задач — часть нормального жизненного цикла async-приложения.

**Типовой вопрос:**  
Почему cancellation нужно обрабатывать явно?

**Ответ:**  
Потому что:
- отмена происходит через исключение
- ресурсы нужно освобождать
- игнорирование отмены ломает shutdown

Корректный async-код обязан быть cancel-safe.

---

## Timeouts в async системах

**Кратко:**  
Timeout ограничивает время ожидания операции.

**Типовой вопрос:**  
Почему таймауты особенно важны в async?

**Ответ:**  
Потому что:
- зависшая задача блокирует ресурсы
- цепочки await растягивают ожидание
- отсутствие таймаутов ведёт к утечкам задач

---

## Async Locks и Semaphores

**Кратко:**  
Async-примитивы синхронизации:
- `asyncio.Lock`
- `Semaphore`
- `BoundedSemaphore`

**Типовой вопрос:**  
Когда async-lock — признак плохого дизайна?

**Ответ:**  
Когда:
- lock используется часто
- защищает большую область
- заменяет изоляцию данных

Async лучше проектировать без shared state.

---

## Backpressure в async системах

**Кратко:**  
Async позволяет легко создавать перегрузку, если не ограничивать конкуренцию.

**Типовой вопрос:**  
Как реализуют backpressure в asyncio?

**Ответ:**  
Основные методы:
- ограничение количества задач
- bounded очереди
- semaphores
- отказ или задержка producer’ов

---

## Типичные ошибки async-кода

**Кратко:**  
Async-код выглядит простым, но ошибки дорого обходятся.

**Типовой вопрос:**  
Какие ошибки чаще всего допускают при использовании asyncio?

**Ответ:**  
Типовые ошибки:
- использование blocking библиотек
- отсутствие таймаутов
- утечки задач
- игнорирование cancellation
- смешивание sync и async без адаптации
