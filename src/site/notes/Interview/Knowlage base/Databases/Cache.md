---
{"dg-publish":true,"permalink":"/interview/knowlage-base/databases/cache/"}
---

## Что такое кэш и зачем он нужен

**Кратко:**  
Кэш — это слой хранения данных с быстрым доступом, который уменьшает нагрузку на основную систему и снижает latency. Кэш может хранить:
- результаты запросов
- вычисления
- сессии
- промежуточные данные

**Типовой вопрос:**  
Что именно нужно кэшировать?

**Ответ:**  
Кэшируют:
- данные с высоким read/write ratio
- дорогие вычисления
- данные с предсказуемым временем жизни

Не кэшируют:
- критичные транзакционные данные
- данные с высокой частотой изменений без TTL

---

## Cache Patterns

**Кратко:**  
Существует несколько стандартных паттернов кэширования, каждый с разными trade-off. Выбор паттерна зависит от того, что важнее: скорость записи, скорость чтения или гарантия сохранности данных.

**Типовой вопрос:**  
В каких случаях стоит использовать Write-Back вместо Cache Aside и какие риски это несет?

**Ответ:**  
- **Cache Aside (Lazy Loading):** Приложение сначала проверяет кэш, при промахе идет в БД и обновляет кэш. Самый популярный и безопасный метод.
    
- **Write-Through:** Данные пишутся одновременно в кэш и в БД. Гарантирует актуальность кэша, но замедляет запись из-за двойной операции.
    
- **Write-Back (Write-Behind):** Данные пишутся только в кэш, а в БД сбрасываются очередью позже. Самый быстрый метод, но при падении кэша данные, не успевшие уйти в БД, будут потеряны.

---

## Cache Invalidation

**Кратко:**  
Это механизм удаления устаревших данных из кэша. Самая сложная задача здесь — найти баланс: удалять данные слишком часто (нагрузка на БД) или хранить «протухшие» значения слишком долго (ошибки в приложении).

**Типовой вопрос:**  
Почему TTL недостаточно для консистентности данных, и какие существуют стратегии синхронизации кэша при обновлении записи в БД?

**Ответ:**  
- **TTL (Time To Live):** Пассивное удаление по таймеру. Не подходит для данных, которые должны быть актуальны мгновенно (например, баланс кошелька). Создаёт всплески нагрузки при одновременном истечении.
    
- **Explicit Invalidation (Явное удаление):** Приложение удаляет ключ из кэша при любом изменении в БД. Это стандарт для обеспечения консистентности.
    
- **Cache Stampede:** Проблема, когда популярный ключ удаляется, и сотни потоков одновременно идут в БД за обновлением. Лечится через блокировки (mutex) или «мягкий» TTL.
    
- **Event-driven (CDC):** База данных сама сообщает через стрим (например, Debezium + Kafka), что данные изменились, и кэш нужно сбросить.

На практике используют комбинации стратегий.

---

## Eviction Policies

**Кратко:**  
Eviction policy определяет, какие данные будут удалены при переполнении кэша.

**Типовой вопрос:**  
Какие eviction policies существуют и чем они отличаются?

**Ответ:**  
- **LRU** — удаляет наименее используемые
- **LFU** — удаляет наименее популярные
- **FIFO** — простая очередь
- **Random** — редко используется

Redis поддерживает все основные варианты.

---

## Distributed Cache (Redis)

**Кратко:**  
Redis — in-memory data store, часто используемый как распределённый кэш.  
Поддерживает:
- различные структуры данных
- репликацию
- персистенцию (AOF и RDB)
- кластеризацию

**Типовой вопрос:**  
Почему Redis однопоточный, и как он умудряется обрабатывать сотни тысяч запросов в секунду?

**Ответ:**  
- **Single-threaded Event Loop:** Redis выполняет команды последовательно в одном потоке, что исключает затраты на контекстное переключение и блокировки (mutex). Скорость достигается за счет неблокирующего ввода-вывода.
    
- **Типы данных:** В отличие от Memcached, Redis поддерживает не только строки, но и `Lists`, `Sets`, `Sorted Sets`, `Hashes` и `Bitmaps`, позволяя переносить часть логики (например, рейтинги или очереди) на сторону кэша.
    
- **Persistence (RDB/AOF):** Redis — это не просто кэш, он может сохранять данные на диск. **RDB** делает быстрые снимки всей памяти, а **AOF** записывает каждую операцию (более надежно, но медленнее).
    
- **Масштабирование:**
    - **Sentinel:** Обеспечивает высокую доступность (автоматическое переключение на реплику при падении мастера).
    - **Cluster:** Горизонтальное масштабирование через шардирование данных.

---

## Cache Stampede и Thundering Herd

**Кратко:**  
Cache stampede — ситуация, при которой значение в кэше истекает или отсутствует, и множество клиентов одновременно идут за данными в основную систему.  
Thundering herd — более общий эффект: большое количество одновременных запросов к одному ресурсу, приводящее к резкому скачку нагрузки.  
Оба эффекта часто приводят к перегрузке БД, росту latency и цепным отказам.

Типичные причины:
- истечение TTL у популярного ключа
- холодный старт сервиса
- рестарт кэша
- отсутствие координации между запросами

**Типовой вопрос:**  
Почему cache stampede опасен даже при наличии кэша?

**Ответ:**  
Проблема в том, что кэш:
- защищает только при hit
- не ограничивает конкуренцию при miss

Когда ключ истекает:
- десятки или сотни запросов одновременно получают miss
- все они идут в БД
- БД получает всплеск нагрузки
- время ответа растёт, система начинает деградировать

Основные техники защиты:
- **Блокировка на ключ** — только один запрос пересчитывает значение
- **Раннее обновление** — значение обновляется до истечения TTL
- **TTL с разбросом** — предотвращает одновременное истечение
- **Фоновое обновление** — обновление без участия клиентского запроса

```python
lock = redis.lock(f"lock:{key}", timeout=5)

if not redis.exists(key):
    with lock:
        if not redis.exists(key):
            value = load_from_db()
            redis.set(key, value, ex=ttl + random.randint(0, 30))
```

---

## Сравнение систем кэширования

**Кратко:**  
Системы кэширования различаются по архитектуре, возможностям масштабирования и дополнительным функциям. Кэш — это часть архитектуры, а не просто ускоритель.

**Типовой вопрос:**  
Почему выбор кэша влияет на архитектуру всей системы?

**Ответ:**  
Потому что кэш определяет:
- модель консистентности
- стратегию отказоустойчивости
- способы инвалидации данных
- нагрузку на основную БД

### Сравнительная таблица кэшей

| **Система**     | **Архитектура потоков**         | **Хранение** | **Сильные стороны**                                         | **Ограничения**                               | **Использование**                                 |
| --------------- | ------------------------------- | ------------ | ----------------------------------------------------------- | --------------------------------------------- | ------------------------------------------------- |
| **Redis**       | Single-threaded                 | RAM + Диск   | Богатые структуры данных, экосистема, предсказуемость       | Одно ядро CPU, блокировки на тяжелых командах | Универсальный стандарт для кэша и очередей        |
| **KeyDB**       | Multi-threaded                  | RAM + Диск   | В 3-7 раз быстрее Redis, активная репликация (Multi-master) | Меньшее комьюнити, чем у Redis                | Высокая нагрузка без перехода на кластер          |
| **Dragonfly**   | Multi-threaded (Shared-nothing) | RAM          | До 25 раз быстрее Redis, эффективное сжатие памяти          | Нет полной поддержки всех модулей Redis       | Экстремальный Highload, замена огромных кластеров |
| **Memcached**   | Multi-threaded                  | RAM          | Максимальная простота, многопоточность «из коробки»         | Только строки, нет сохранения на диск         | Простой кэш данных без логики                     |
| **Local cache** | In-process                      | RAM          | Нулевая сетевая задержка (L1 кэш)                           | Рассинхрон между нодами, риск OOM             | Конфиги, справочники, очень "горячие" объекты     |
| **CDN cache**   | Edge                            | Disk/RAM     | Географическая близость к юзеру, экономия трафика           | Сложная инвалидация, только публичные данные  | Статика (картинки, JS), тяжелые GET-запросы       |

Практические выводы:
- Redis — стандарт для backend-систем
- Memcached подходит для простых сценариев
- локальный кэш снижает latency, но усложняет консистентность
- CDN решает сетевую задержку, а не бизнес-логику
- KeyDB и Dragonfly > ~100k RPS