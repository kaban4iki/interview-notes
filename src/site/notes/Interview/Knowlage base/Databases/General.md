---
{"dg-publish":true,"permalink":"/interview/knowlage-base/databases/general/"}
---

## ACID на практике

**Кратко:**  
ACID описывает свойства транзакций, но в реальных системах они реализуются с разной степенью строгости.

**Атомарность** гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем.
**Консистентность данных** — это свойство системы, при котором данные сохраняют свою целостность, достоверность и согласованность независимо от времени, места и способа доступа к ним.
**Изолированность**. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.
**Надёжность.** Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

**Типовой вопрос:**  
Какие свойства ACID чаще всего ослабляют и почему?

**Ответ:**  
Чаще всего ослабляют:
- **Isolation** — ради параллелизма и производительности
- **Consistency** — в распределённых сценариях

Atomicity и Durability обычно сохраняются, так как без них система становится непредсказуемой.

---

## CAP Theorem

**Кратко:**  
CAP theorem описывает компромисс между:
- **Consistency** — все клиенты видят одинаковые данные
- **Availability** — система отвечает на каждый запрос
- **Partition tolerance** — система работает при сетевых разделениях

В распределённых системах всегда выбирают только два из трёх.

**Типовой вопрос:**  
Как CAP применим к реальным системам?

**Ответ:**  
При сетевом разделении система вынуждена выбирать между:
- консистентностью данных
- доступностью ответов

В нормальном режиме большинство систем стараются обеспечивать и то и другое.  
Компромисс проявляется именно во время сбоев сети.

---

## Модели согласованности (Consistency Models)

**Кратко:**  
Модели согласованности определяют правила, по которым узлы распределенной системы видят изменения данных после записи. Это своего рода контракт между системой и разработчиком, который устанавливает баланс между скоростью ответа и актуальностью информации на разных репликах.

**Типовой вопрос:**  
Какие бывают виды согласованности?

**Ответ:**  
- **Strong Consistency (Строгая):** Гарантирует, что после завершения записи любое чтение из любого узла вернет самое свежее значение. Система ведет себя как один узел, но это требует блокировок и сильно увеличивает задержки (latency).
    
- **Eventual Consistency (Согласованность в конечном счете):** Самая слабая модель, где данные синхронизируются между узлами постепенно. В моменте разные пользователи могут видеть разные версии данных, но при отсутствии новых записей все узлы придут к единому состоянию.
    
- **Causal Consistency (Причинная):** Гарантирует порядок только для связанных событий: если ответ Б был вызван сообщением А, все увидят А раньше Б. Это "золотая середина", позволяющая избежать логических парадоксов (например, комментарий не появится раньше самого поста).
    
- **Read-Your-Writes:** Частный случай, гарантирующий пользователю, что он всегда увидит свои собственные обновления сразу после отправки, даже если для остальных данные еще «старые».
    
- **Monotonic Read:** Гарантирует, что если пользователь увидел определенное значение, он больше никогда не увидит более старую версию этого значения при последующих запросах.

---

## Транзакции в распределённых системах

**Кратко:**  
Это операции, затрагивающие данные на нескольких независимых узлах или разных базах данных одновременно. Они гарантируют атомарность (всё или ничего) в масштабе всей сети, но создают огромные задержки из-за необходимости синхронизации всех участников.

**Типовой вопрос:**  
Почему классический протокол 2PC (Two-Phase Commit) считается неэффективным в высоконагруженных системах?

**Ответ:**  
- **Блокировки:** Пока все узлы не подтвердят готовность, ресурсы (строки в БД) заблокированы; если один узел «подвис», стоит вся система.
    
- **Partial Failures:** Если координатор транзакции упадет в момент подтверждения, система может остаться в неопределенном состоянии, требующем ручного вмешательства.
    
- **Альтернатива — Sagas:** Вместо одной долгой транзакции процесс разбивается на цепочку локальных шагов; если что-то идет не так, выполняются «компенсирующие запросы» (отмена предыдущих действий).
    
- **Eventual Consistency:** Вместо жесткой ACID-согласованности в распределенных системах чаще выбирают асинхронные очереди (Kafka/RabbitMQ), чтобы данные «доехали» до всех узлов постепенно (Transactional Outbox).

---

## Индексы

**Кратко:**  
Индекс ускоряет чтение данных за счёт замедления записи и увеличения потребления памяти.

**Типовой вопрос:**  
Почему нельзя бездумно добавлять индексы?

**Ответ:**  
Потому что каждый индекс:
- замедляет INSERT и UPDATE
- увеличивает размер данных
- усложняет планировщик запросов

---

## Миграции схемы

**Кратко:**  
Миграции — это версионируемый процесс изменения структуры БД, который в высоконагруженных системах превращается в инженерную задачу по управлению блокировками. Основная цель — изменить схему без простоя (Zero Downtime), обеспечив одновременную работу старой и новой версий кода.

**Типовой вопрос:**  
Как добавить колонку со значением по умолчанию в таблицу на 100 млн строк без остановки приложения?

**Ответ:**  
Вместо одного опасного действия процесс разбивается на 3–5 этапов:
- **Expand:** Добавляем новую колонку (разрешаем NULL или без дефолта, чтобы избежать блокировок).
- **Migrate:** Фоновым скриптом порциями (batching) переносим данные из старой колонки в новую.
- **Update:** Обновляем код приложения, чтобы он писал в обе колонки, но читал из новой.
- **Contract:** Удаляем старую колонку и код, который её поддерживал.

---

## Replica Lag

**Кратко:** 
Это задержка между записью данных в Master-ноду и их появлением на Replica-ноде. Возникает из-за нагрузки на сеть или медленного применения логов транзакций на реплике.

**Типовой вопрос:** 
Как решить проблему Read-after-Write inconsistency, если пользователь обновил профиль, а при рефреше страницы видит старые данные из реплики?

**Ответ:**
- **Read-your-writes consistency:** После записи направлять чтение этого пользователя на Master в течение пары секунд (пока лаг не пройдет).
- **Causal Consistency:** Использовать номера транзакций (LSN). Если реплика «отстает» от нужного LSN, ждать обновления или идти в Master.
- **Синхронная репликация:** Master ждет подтверждения от реплики перед ответом клиенту (гарантирует отсутствие лага, но сильно замедляет запись).