---
{"dg-publish":true,"permalink":"/interview/knowlage-base/python/python-internals/"}
---

## Как Python исполняет код

**Кратко:**  
Код компилируется в bytecode и исполняется виртуальной машиной CPython.

**Типовой вопрос:**  
Что такое bytecode?

**Ответ:**  
Это промежуточное представление Python-кода, которое исполняет VM.

---

## GIL (Global Interpreter Lock)

**Кратко:**  
GIL гарантирует, что bytecode выполняется одним потоком.

**Типовой вопрос:**  
Почему GIL мешает CPU-параллелизму?

**Ответ:**  
Потому что только один поток может выполнять Python bytecode одновременно.

---

## No-GIL (PEP 703) в Python 3.13+

**Кратко:** 
Это экспериментальный режим (Free-threaded Python), позволяющий запускать настоящий параллелизм в потоках (Threads) без глобальной блокировки интерпретатора.

**Типовой вопрос:** 
Как изменится работа с многопоточностью в Python после полного отказа от GIL?

**Ответ:**
- **CPU-bound задачи:** Теперь можно будет эффективно использовать `threading` для вычислений на всех ядрах CPU (сейчас это возможно только через `multiprocessing`).
- **Thread Safety:** Проблема Race Conditions станет острее. Если раньше GIL давал «мнимую» атомарность некоторых операций, то теперь разработчикам придется активнее использовать `Lock` и `Rendezvous`.
- **Библиотеки:** Главный вызов — адаптация C-extensions (NumPy и т.д.), которые десятилетиями полагались на наличие GIL.

---

##  Профилирование

**Кратко:**  
Оптимизация начинается с измерений.

```python
import cProfile

cProfile.run("my_func()")
```

**Типовой вопрос:**  
Какие инструменты профилирования ты используешь?

**Ответ:**  
CPU — `cProfile`, `line_profiler`.  
Memory — `tracemalloc`.

---

## Когда Python — плохой выбор

**Кратко:**  
Python не универсален.

**Типовой вопрос:**  
В каких случаях Python — плохой выбор?

**Ответ:**  
Для тяжёлых CPU задач, т.к. у него низкая скорость выполнения по сравнению с компилируемыми языками
Для высоконагруженных real-time систем, т.к. автоматическое управление памятью может вызывать паузы в работе приложения
Тогда узкие места выносят в отдельные микросервисы на других языках.

---

## Декораторы

**Кратко:**
Декоратор — это функция (или объект), которая **оборачивает другую функцию или класс**, изменяя или расширяя их поведение **без изменения исходного кода**.

```python
from functools import wraps

def log_call(fn):
	@wraps(fn) # Без `wraps` теряются: __name__, __doc__ и сигнатура функции
    def wrapper(*args, **kwargs):
        print(fn.__name__)
        return fn(*args, **kwargs)
    return wrapper

@log_call
def add(a: int, b: int) -> int:
    return a + b
```


---

## Менеджеры контекста и оператор `with`

**Кратко:**
Менеджеры контекста позволяют выделять и освобождать ресурсы именно тогда, когда надо. Наиболее распространенным использованием является оператор `with`.

**Типовой вопрос:**  
Что такое контекстный менеджер?

**Ответ:**
Это класс который реализует методы `__enter__` и `__exit__`.

- `__enter__`: Настраивает контекст и возвращает ресурс.
- `__exit__`: Очищает ресурс (закрывает файл, освобождает блокировку) даже в случае возникновения исключения.

Также можно использовать декоратор `contextlib.contextmanager` и обернуть им генератор, тогда тоже получится контекстный менеджер
```python
from contextlib import contextmanager

@contextmanager
def managed_resource(*args, **kwds):
    # Code to acquire resource, e.g.:
    resource = acquire_resource(*args, **kwds)
    try:
        yield resource
    finally:
        # Code to release resource, e.g.:
        release_resource(resource)
```