---
{"dg-publish":true,"permalink":"/interview/knowlage-base/python/async-python/"}
---

## Threads, Processes и AsyncIO

**Кратко:**  
Разные модели конкурентного выполнения.

**Процессы —** это отдельные программы, каждая со своей памятью, которые могут работать параллельно на разных ядрах процессора.
**Потоки —** это части одного процесса, которые одновременно выполняют задачи и используют для этого общую память.

**Типовой вопрос:**  
Когда использовать async, а когда потоки или процессы?

**Ответ:**  
Threads — I/O-bound задачи (для синхронизации можно использовать Lock, Semaphore, Event), обычно используются с легаси библиотеками, которые не поддерживают async/await синтаксис, или для реализации фоновых задач.  
Processes — CPU-bound задачи из-за GIL.
AsyncIO — позволяет выполнять задачи без блокировки основного потока, так как управляет задачами в одном потоке через цикл событий.

---

## Event Loop

**Кратко:**  
Event loop планирует и переключает корутины.

```python
import asyncio

async def main():
	await asyncio.sleep(1)

asyncio.run(main())
```

**Типовой вопрос:**  
Что делает event loop?

**Ответ:**  
Он управляет выполнением корутин и переключается между ними при `await`.

---

## `async` / `await`

**Кратко:**  
`async` создаёт корутину,  
`await` отдаёт управление event loop.

**Типовой вопрос:**  
Что будет, если забыть `await`?

**Ответ:**  
Вернётся coroutine object, код не выполнится и появится warning.


---

## gather vs as_completed

**Кратко:** 
Оба метода запускают корутины конкурентно, но различаются способом обработки результатов и порядком их получения.

**Типовой вопрос:** 
В чем ключевая разница между `asyncio.gather` и `asyncio.as_completed` при обработке списка задач?

**Ответ:**
- **`asyncio.gather`:** Ждет выполнения **всех** задач и возвращает список результатов в том же порядке, в котором передавались задачи. Если одна упадет, остальные продолжат работать, но результат будет сложно получить без флага `return_exceptions=True`.
    
- **`asyncio.as_completed`:** Возвращает итератор, который выдает результаты по мере их **готовности**. Это позволяет сразу начать обработку первого пришедшего ответа (например, самого быстрого из нескольких API), не дожидаясь остальных.