---
{"dg-publish":true,"permalink":"/interview/knowlage-base/python/core/"}
---

## Mutable и Immutable объекты

**Кратко:**
Immutable объекты нельзя изменить — создаётся новый объект.  
Mutable можно менять in-place.
```python
a = [1, 2]
b = a
b.append(3)
# a == [1, 2, 3]
```

**Типовой вопрос:**  
В чём разница между mutable и immutable и почему это важно?

**Ответ:**
Mutable объекты могут приводить к shared state и побочным эффектам.  
Это критично для default arguments, передачи аргументов и конкурентного кода.

---

## Default arguments в функциях

**Кратко:**
Аргументы по умолчанию вычисляются при объявлении функции, а не при вызове.

**Типовой вопрос:**  
Почему default arguments вычисляются один раз?

**Ответ:**  
Потому что default arguments — часть объекта функции и инициализируются при выполнении `def`.  
Использование mutable объектов приводит к общему состоянию между вызовами.

---

## `==` vs `is`

**Кратко:**  
`==` сравнивает значения,  
`is` проверяет identity (тот же объект в памяти).

```python
a = [1, 2] 
b = [1, 2]  
a == b   # True 
a is b   # False
```

**Типовой вопрос:**  
Когда корректно использовать is?

**Ответ:**  
Для проверки identity, чаще всего с `None`, `True` и `False`.  
Для сравнения значений всегда используется `==`.

---

## Области видимости (LEGB)

**Кратко:**  
Python ищет имена в порядке: 
Local(в текущей функции) → 
Enclosing(во внешних функциях (если текущая функция вложенная)) → 
Global(на уровне модуля) → 
Built-ins(в пространстве имён встроенных функций и объектов.

```python
x = 10 
 
def outer():
	x = 20

	def inner():
		return x
	
	return inner()
```

**Типовой вопрос:**  
В чём разница между `nonlocal` и `global`?

**Ответ:**  
`nonlocal` изменяет переменную из enclosing scope,  
`global` — из module scope.  
Оба ухудшают читаемость и используются ограниченно.

---

## `__new__` и `__init__`

**Кратко:**  
`__new__` создаёт объект,  
`__init__` инициализирует уже созданный.

```python
class A:     
	def __new__(cls):         
		return super().__new__(cls)      
	
	def __init__(self):         
		pass
```

**Типовой вопрос:**  
Когда нужен `__new__`?

**Ответ:**  
Редко: для изменения процесса создания наследников immutable типов, реализации singleton-паттернов и при работе с metaclasses.

---

## Итераторы и генераторы

**Кратко:**  
Итератор реализует `__iter__` и `__next__`.  
Генератор — удобный способ создать итератор.

```python
class MyNumbers:
	def __init__(self, n: int):
		self.a = 1
		self.b = n

    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
	    if self.a == self.b:
		    raise StopIteration
	
        x = self.a
        self.a += 1
        return x
```

```python
def sequence_gen(n):
  for x in range(1, n + 1):
    yield x
```

**Типовой вопрос:**  
Чем генератор отличается от списка?

**Ответ:**  
Генератор вычисляет значения лениво и не хранит всё в памяти,  
что важно для больших объёмов данных и стриминга.

---

## Исключения

**Кратко:**  
Исключения это механизм обработки ошибок в рантайме.

`try` проверяет код на наличие исключений
`except` код, который будет выполняться, если в блоке `try` нашлась ошибка
`finally` код, который будет выполняться независимо от того, была ли найдена ошибка или нет
`else` выполняется, если try не нашёл исключений

---

## Управление памятью и GC

**Кратко:**  
Python использует reference counting и cyclic garbage collector.

```python
import gc 
gc.collect()
```

**Типовой вопрос:**  
Как Python освобождает память?

**Ответ:**  
Объекты удаляются при нулевом refcount,  циклические ссылки чистятся GC. 
Сборщик мусора Python делит объекты на три поколения (0, 1, 2). Новые объекты начинают в поколении 0. Если они переживают сборку, они перемещаются в следующее поколение. Более старые поколения собираются реже, чтобы повысить производительность.

---

## Метаклассы

**Кратко:**
Метакласс — это класс для классов.  
Он определяет, **как создаются классы**, так же как класс определяет, как создаются объекты.
По умолчанию, все классы экземпляры метакласса `type`.

```python
class Meta(type):
    def __new__(cls, name, bases, namespace):
        namespace["created_by"] = "meta"
        return super().__new__(cls, name, bases, namespace)

class A(metaclass=Meta):
    pass

A.created_by  # "meta"
```

**Типовой вопрос:**
Что такое метакласс и зачем он нужен?

**Ответ:**
Метакласс позволяет перехватить и изменить процесс создания класса:  
проверить структуру, автоматически добавить методы или атрибуты, навязать правила для всех классов.