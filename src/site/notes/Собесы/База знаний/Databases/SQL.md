---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/databases/sql/"}
---

## Реляционная модель

**Кратко:**  
Реляционные базы данных сущностями со связями и строгой схемой данных.

**Типовой вопрос:**  
Почему реляционная модель до сих пор доминирует?

**Ответ:**  
Потому что она:
- хорошо описывает бизнес-домены
- поддерживает сложные запросы
- обеспечивает целостность данных

Для сложных связей и инвариантов SQL остаётся наиболее удобным инструментом.

---

## Нормализация и денормализация

**Кратко:**  
Нормализация уменьшает дублирование данных, денормализация повышает скорость чтения.

**Типовой вопрос:**  
Когда сознательно нарушают нормальные формы?

**Ответ:**  
Когда:
- система read-heavy
- JOIN’ы становятся узким местом
- данные редко изменяются

Денормализация — управляемый компромисс, а не ошибка проектирования.

---

## Транзакции и уровни изоляции

**Кратко:**  
Уровень изоляции определяет, какие аномалии допустимы при параллельных транзакциях.
1. **Read Uncommitted** — наименее строгий, допускает доступ к незафиксированным изменениям других транзакций («грязное чтение»). В PostgreSQL этот уровень фактически отсутствует — при его запросе система автоматически повышает уровень до Read Committed.
2. **Read Committed** — гарантирует доступ только к зафиксированным данным, исключая проблему грязного чтения. Этот уровень установлен по умолчанию в PostgreSQL и многих других современных СУБД.
3. **Repeatable Read** — исключает неповторяемое чтение, обеспечивая неизменность данных, прочитанных в рамках транзакции, до момента её завершения. В PostgreSQL, благодаря технологии MVCC, этот уровень также предотвращает появление фантомных чтений.
4. **Serializable** — максимальный уровень изоляции, обеспечивает полную изоляцию транзакций, как если бы они выполнялись строго последовательно, что полностью исключает все возможные аномалии.

**Типовой вопрос:**  
Почему SERIALIZABLE используют редко?

**Ответ:**  
Потому что:
- сильно снижает параллелизм
- увеличивает количество блокировок
- плохо масштабируется

Чаще используют:
- READ COMMITTED
- REPEATABLE READ

---

## Locking и блокировки

**Кратко:**  
Это механизм управления одновременным доступом к данным, который предотвращает конфликты и поддерживает целостность данных
Блокировки защищают данные, но напрямую влияют на производительность.
Некоторые виды блокировок в PostgreSQL
- **Блокировки на уровне таблицы**. Например, ACCESS EXCLUSIVE — блокирует доступ других транзакций к объекту, обычно используется для деструктивных операций (например, удаления или усечения таблицы). 
- **Блокировки на уровне строки**. Например, FOR UPDATE — блокирует строки, полученные оператором SELECT, как для изменения, что предотвращает их блокировку, изменение или удаление другими транзакциями до завершения текущей транзакции.

**Типовой вопрос:**  
Почему блокировки опасны под нагрузкой?

**Ответ:**  
Потому что:
- создают очереди ожидания
- увеличивают latency
- могут приводить к deadlock’ам

Минимизация времени транзакций критична.

---

## Индексы в SQL

**Кратко:**  
**Индекс в SQL** — это специальная структура данных, связанная с таблицей и конкретными столбцами в ней. Она содержит копии данных из индексируемых столбцов, отсортированные в определённом порядке, и указатели на фактическое местоположение соответствующих строк в таблице.

Некоторые виды индексов в SQL:
- **Кластеризованные** — определяют физическое расположение строк в таблице, данные физически сортируются по ключам этого индекса. Каждая таблица может иметь только один кластеризованный индекс. 
- **Некластеризованные** — содержат логически отсортированные ключи вместе со ссылками на соответствующие строки в таблице, данные в самой таблице остаются несортированными. Одна таблица может содержать несколько некластеризованных индексов.
- **Уникальные** — гарантируют, что значения в индексе не повторяются. Часто используются для первичных ключей.
- **Составные** — создаются для нескольких столбцов одновременно, полезны для ускорения запросов, которые используют фильтры по двум и более полям.
- **Частичные** — создаются только для подмножества строк, удовлетворяющих определённому условию. Это полезно, когда нужно оптимизировать запросы, работающие только с определённой частью данных.
- **Функциональные** — позволяют индексировать результаты выражений или функций, что может быть полезно, если запросы часто используют такие выражения.

**Типовой вопрос:**  
Какие существуют типы индексов?

**Ответ:** 
Некоторые из них:
- **B-Tree:** По умолчанию и наиболее распространенный. Хорошо подходит для запросов диапазона и проверок равенства.
- **Hash Index:** Хорошо подходит только для проверок равенства (key = value). Очень быстрый, но не поддерживает запросы диапазона.
- **GiST / GIN:** Используется для сложных типов данных, таких как полнотекстовый поиск, геометрические данные или JSONB (в PostgreSQL).

---

## JOIN’ы и их стоимость

**Кратко:**  
JOIN — это операция сопоставления строк из двух таблиц на основе общего условия. На физическом уровне СУБД реализует это через алгоритмы вложенных циклов, хеширования или сортировки в зависимости от объема данных и индексов.

**Типовой вопрос:**  
Какие существуют виды JOIN и как они работают с несовпадающими данными в обеих таблицах?

**Ответ:**  
- **INNER JOIN:** Возвращает только те записи, для которых найдено соответствие в обеих таблицах; строки без пары отбрасываются.
- **LEFT JOIN:** Сохраняет все строки из левой таблицы, дополняя их данными из правой или значениями `NULL`, если совпадений нет.
- **RIGHT JOIN:** Зеркален левому соединению — приоритет отдается правой таблице, часто заменяется на LEFT JOIN путем смены таблиц местами для лучшей читаемости.
- **FULL OUTER JOIN:** Комбинирует LEFT и RIGHT, сохраняя все записи из обеих таблиц и заполняя недостающие данные `NULL` с обеих сторон.
- **CROSS JOIN:** Формирует декартово произведение, где каждая строка первой таблицы соединяется с каждой строкой второй (результат: $N \times M$ строк).
- **SELF JOIN:** Соединение таблицы с самой собой, необходимое для обработки иерархических структур, например, связи «сотрудник — руководитель».

---

## Транзакции в SQL БД

**Кратко:**  
Транзакция — это последовательность операций, которая выполняется как единое целое и переводит базу данных из одного согласованного состояния в другое.

**Типовой вопрос:**  
Какие этапы проходит транзакция внутри SQL базы данных?

**Ответ:**  
Жизненный цикл транзакции обычно выглядит так:

1. **BEGIN / START TRANSACTION**  
   База данных создаёт транзакционный контекст.  
   Все последующие операции изолируются от других транзакций в рамках выбранного уровня изоляции.

2. **Выполнение операций (DML)**  
   `SELECT`, `INSERT`, `UPDATE`, `DELETE`:
   - изменения пишутся в WAL / undo log
   - данные могут блокироваться или версионироваться (MVCC)
   - другие транзакции видят данные согласно уровню изоляции

3. **Фиксация или откат**
   - **COMMIT**: изменения становятся видимыми другим транзакциям
   - **ROLLBACK**: все изменения отменяются

4. **Освобождение ресурсов**
   - снимаются блокировки
   - очищается транзакционный контекст
   - версии данных могут быть позже собраны GC / vacuum

---

## Оптимизация SQL-запросов

**Кратко:**  
Оптимизация SQL — это работа с тем, как база данных планирует и выполняет запросы. Основные цели: уменьшить объём обрабатываемых данных, сократить количество операций ввода-вывода и избежать лишних вычислений. В реальной системе оптимизация почти всегда начинается с анализа планов выполнения и индексов.

Ключевые области оптимизации:
- корректные индексы
- структура запросов
- объём возвращаемых данных
- порядок и способ соединения таблиц

**Типовой вопрос:**  
С чего начинается оптимизация медленного SQL-запроса?

**Ответ:**  
Всегда с анализа плана выполнения (`EXPLAIN / EXPLAIN ANALYZE`).

План показывает:
- какие индексы используются
- где происходит full scan
- порядок join-ов
- фактическое vs ожидаемое количество строк
- самые дорогие операции по времени

Типичные проблемы и решения:

| Проблема                | Как проявляется                    | Причина                               | Решение                                |
| ----------------------- | ---------------------------------- | ------------------------------------- | -------------------------------------- |
| Нет индекса             | Seq Scan, высокий latency          | Фильтрация по неиндексированному полю | Добавить индекс                        |
| Индекс не используется  | Seq Scan при наличии индекса       | Неподходящий порядок колонок          | Пересобрать составной индекс           |
| SELECT *                | Высокая нагрузка на сеть           | Чтение лишних колонок                 | Выбирать только нужные поля            |
| Функции в WHERE         | Индекс не применяется              | Вычисления над колонкой               | Функциональный индекс или нормализация |
| JOIN без фильтрации     | Большой объём промежуточных данных | Соединение крупных таблиц             | Фильтровать до JOIN                    |
| Подзапросы              | Много вложенных операций           | Неоптимальный план                    | Переписать в JOIN или CTE              |
| ORDER BY без индекса    | Сортировка в памяти или на диске   | Нет подходящего индекса               | Добавить индекс под сортировку         |
| OFFSET с большим числом | Линейная деградация                | Пропуск строк                         | Использовать keyset pagination         |
| Длительные транзакции   | Блокировки, рост latency           | Долгий удерживаемый контекст          | Сократить время транзакции             |
| Устаревшая статистика   | Плохой план                        | Нет актуальных данных у оптимизатора  | ANALYZE / VACUUM                       |

---

## Основные SQL базы данных (сравнение)

**Кратко:**  
SQL базы данных различаются по архитектуре, расширяемости, возможностям масштабирования и типичным сценариям использования.

**Типовой вопрос:**  
Как выбирать SQL базу данных под конкретный проект?

**Ответ:**  
Выбор зависит от:
- сложности запросов
- требований к согласованности
- объёма данных
- операционной среды

### Сравнительная таблица

| БД                  | Ключевые особенности          | Сильные стороны                             | Ограничения                   | Типичные кейсы                      |
| ------------------- | ----------------------------- | ------------------------------------------- | ----------------------------- | ----------------------------------- |
| **PostgreSQL**      | Расширяемая архитектура, MVCC | Богатый SQL, JSONB, индексы, расширения     | Более сложная эксплуатация    | Core backend, сложная бизнес-логика |
| **MySQL / MariaDB** | Простота, широкая поддержка   | Быстрые простые запросы, простая репликация | Менее строгая семантика SQL   | Web-приложения, read-heavy          |
| **SQLite**          | Встраиваемая БД               | Нет сервера, простота                       | Нет concurrency под нагрузкой | CLI, тесты, embedded                |
| **MS SQL Server**   | Enterprise-ориентация         | Инструменты, аналитика                      | Лицензирование                | Корпоративные системы               |
| **Oracle DB**       | Максимальная функциональность | Надёжность, масштаб                         | Сложность и стоимость         | Крупный enterprise                  |

Практические выводы:
- PostgreSQL — де-факто стандарт для backend-систем
- MySQL подходит для простых сценариев с высокой нагрузкой
- SQLite — не server-side БД
- Enterprise БД оправданы в строго регламентированных средах