---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/system-design/core/"}
---

## Latency, Throughput, Load

**Кратко:**  
Базовые метрики любой системы:
- **Latency** — время ответа
- **Throughput** — запросов в секунду
- **Load** — текущая нагрузка

Они связаны, но не равны.

**Типовой вопрос:**  
Почему высокая throughput не гарантирует низкую latency?

**Ответ:**  
Потому что:
- очереди увеличивают latency
- batching ускоряет обработку, но замедляет ответ
- блокировки растут под нагрузкой

---

## CAP теорема

**Кратко:**  
CAP описывает компромисс между:
- **Consistency** — согласованность
- **Availability** — доступность
- **Partition tolerance** — устойчивость к сетевым разделениям

**Типовой вопрос:**  
Почему нельзя иметь C, A и P одновременно?

**Ответ:**  
Потому что при сетевом разделении:
- либо система продолжает отвечать (A), но теряет согласованность
- либо сохраняет согласованность (C), но отказывает в обслуживании

Выбор зависит от бизнес-требований.

---

## SLA, SLO, SLI

**Кратко:**  
Эти понятия описывают качество сервиса:
- **SLI (Service Level Indicators)** — измеряемый показатель (latency, error rate)
- **SLO (Service Level Objectives)** — целевое значение для SLI, которого команда стремится достичь.
- **SLA (Service Level Agreement)** — соглашение об уровне обслуживания между поставщиком услуги и клиентом.

**Типовой вопрос:**  
Зачем SLO инженеру, а не бизнесу?

**Ответ:**  
SLO:
- задаёт границы оптимизации
- помогает принимать решения о рисках
- определяет, когда система «достаточно хороша»

Без SLO оптимизация бесконечна.

---

## Single Point of Failure

**Кратко:**  
Single Point of Failure (SPOF) — компонент, отказ которого ломает систему целиком.

**Типовой вопрос:**  
Почему SPOF часто появляется незаметно?

**Ответ:**  
Потому что:
- появляется как временное решение
- скрыт за abstraction
- не учитывается в happy path

SPOF — результат эволюции системы без пересмотра архитектуры.

---

## Horizontal vs Vertical Scaling

**Кратко:**  
Существует два подхода масштабирования:
- **Vertical** — усиление одного узла
- **Horizontal** — добавление узлов

В распределённых системах доминирует horizontal scaling.

**Типовой вопрос:**  
Почему vertical scaling ограничен?

**Ответ:**  
Потому что:
- есть физический предел
- дорого
- не решает отказоустойчивость

Horizontal scaling требует stateless-дизайна.

---

## Stateless vs Stateful сервисы

**Кратко:**  
Stateless сервис не хранит состояние между запросами.  
Stateful — хранит.

**Типовой вопрос:**  
Почему stateless сервисы проще масштабировать?

**Ответ:**  
Потому что:
- любой запрос можно отправить на любой инстанс
- не нужны sticky sessions
- проще балансировка и автоскейлинг

Состояние выносится во внешние хранилища.

---

## Кэширование как системный приём

**Кратко:**  
Кэширование используется для:
- снижения latency
- уменьшения нагрузки
- повышения устойчивости

**Типовой вопрос:**  
Почему кэш усложняет систему?

**Ответ:**  
Потому что:
- появляется проблема актуальности данных
- возникают race condition
- сложнее отлаживать поведение

---

## Consistency моделей данных

**Кратко:**  
В распределённых системах используются разные модели согласованности:
- **Strong consistency (строгая согласованность)**  
  После успешной записи все последующие чтения на любых узлах возвращают новое значение.  Система ведёт себя как единое целое, но платой становятся latency и доступность.
- **Eventual consistency (конечная согласованность)**  
  После записи данные со временем распространяются по всем репликам.  
  В краткосрочной перспективе чтения могут возвращать устаревшие значения, но при отсутствии новых записей система сходится к одному состоянию.
- **Read-after-write consistency**  
  Клиент, выполнивший запись, гарантированно видит своё обновление при последующих чтениях.  Для остальных клиентов такой гарантии может не быть. Часто используется в пользовательских сценариях.
- **Causal consistency (причинная согласованность)**  
  Если операция B логически следует за операцией A, то все клиенты увидят A перед B.  
  Несвязанные операции могут наблюдаться в разном порядке. Баланс между строгой и конечной согласованностью.

**Типовой вопрос:**  
Почему eventual consistency часто приемлема?

**Ответ:**  
Потому что:
- снижает latency
- упрощает масштабирование
- подходит для большинства бизнес-сценариев