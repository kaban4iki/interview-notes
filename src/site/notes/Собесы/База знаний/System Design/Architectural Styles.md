---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/system-design/architectural-styles/"}
---

## Monolith

**Кратко:**  
Монолит — система, где вся функциональность реализована в одном приложении.  
Единая база кода, единое деплой-окружение, все компоненты связаны напрямую.

**Типовой вопрос:**  
Почему монолит всё ещё используется?

**Ответ:**  
- Простота разработки и тестирования  
- Легче настроить локальное окружение  
- Нет необходимости в сложной инфраструктуре  
- Хорош для MVP и небольших команд  

**Минусы:**  
- Ограниченная масштабируемость  
- Сложно разделять ответственность  
- Любое изменение требует деплоя всего приложения  

---

## Modular Monolith

**Кратко:**  
Монолит с чётко разделёнными модулями.  
Каждый модуль изолирован через интерфейсы, имеет свои границы, но деплоится вместе с другими.

**Типовой вопрос:**  
В чём преимущество модульного монолита?

**Ответ:**  
- Лёгкая реорганизация кода  
- Модули тестируются и разрабатываются независимо  
- Подготовка к микросервисной архитектуре  

**Минусы:**  
- Всё ещё один деплой, SPOF остаётся  
- Частично сохраняется высокая связность между модулями  

---

## Microservices

**Кратко:**  
Архитектурный стиль, где система разбита на независимые сервисы, каждый со своей бизнес-логикой и хранилищем данных.  
Компоненты взаимодействуют через API или события.

**Типовой вопрос:**  
Почему микросервисы усложняют систему?

**Ответ:**  
- Появляются сетевые сбои  
- Нужно управление сервисами и оркестрация  
- Требуется мониторинг (logging, tracing, metrics)  
- Сложнее поддерживать согласованность данных  

**Плюсы:**  
- Масштабирование отдельных сервисов  
- Независимый деплой  
- Лёгкая замена технологий  

**Минусы:**  
- Сложнее тестирование и дебаг 
- Требуется Service Discovery  
- Проблемы с транзакциями распределённых данных  

---

## Event-driven architecture

**Кратко:**  
Компоненты взаимодействуют через события.  
События публикуются в шину сообщений и обрабатываются асинхронно другими сервисами.

**Типовой вопрос:**  
Когда EDA предпочтительна?

**Ответ:**  
- Высокая нагрузка на систему  
- Требуется слабая связь между сервисами  
- Необходимо реагировать на события в реальном времени  

**Плюсы:**  
- Масштабируемость через асинхронность  
- Устойчивость к временной недоступности компонентов  
- Расширяемость без изменения существующих сервисов  

**Минусы:**  
- Сложнее отслеживать поток событий  
- Сложнее обеспечивать согласованность  
- Требует зрелой системы мониторинга  

---

## Layered / N-tier Architecture

**Кратко:**  
Традиционная многослойная архитектура: presentation, business, data access.  
Каждый слой отвечает за конкретную часть логики.

**Типовой вопрос:**  
Почему layered architecture популярна?

**Ответ:**  
- Чёткое разделение ответственности  
- Легче тестировать отдельные слои  
- Простая структура для небольших команд  

**Минусы:**  
- Сложно масштабировать горизонтально  
- Часто возникает сильная связь между слоями  
- Избыточная передача данных между слоями  

---

## Hexagonal (Ports & Adapters)

**Кратко:**  
Цель — изолировать ядро приложения от внешних зависимостей.  
Ядро взаимодействует с внешним миром через порты и адаптеры.

**Типовой вопрос:**  
Почему hexagonal улучшает тестируемость?

**Ответ:**  
- Ядро не зависит от инфраструктуры  
- Можно подставлять mock-адаптеры  
- Замена внешних систем минимально влияет на бизнес-логику  

**Плюсы:**  
- Чёткое разделение бизнес-логики и интеграций  
- Простое тестирование и рефакторинг  
- Подготовка к распределённой системе  

**Минусы:**  
- Нужно проектировать интерфейсы заранее  
- Локальная сложность выше, чем у простого монолита  

---

## Service-Oriented Architecture (SOA)

**Кратко:**  
Архитектура, где система состоит из сервисов, объединённых через шину сообщений или API.  
Более крупная и тяжёлая по сравнению с микросервисами, ориентирована на корпоративные интеграции.

**Типовой вопрос:**  
Чем SOA отличается от микросервисов?

**Ответ:**  
- SOA использует крупные, часто монолитные сервисы  
- Микросервисы более мелкие, автономные  
- В SOA часто общая шина и централизованная логика  

---

## Comparison Table: Architectural Styles

| Стиль                 | Плюсы                                   | Минусы                                 | Применение                         |
|-----------------------|----------------------------------------|----------------------------------------|------------------------------------|
| Monolith              | Простота, единый деплой                | Ограниченная масштабируемость, SPOF    | Малые проекты, MVP                 |
| Modular Monolith      | Изоляция модулей, подготовка к микросервисам | Один деплой, частичная связность       | Средние проекты                    |
| Microservices         | Масштабирование, независимый деплой    | Сложность, сетевые ошибки              | Крупные распределённые системы     |
| Event-driven          | Масштабируемость, loose coupling       | Сложнее трассировка и согласованность  | Реактивные системы, очереди       |
| Layered / N-tier      | Простота, тестируемость                | Трудно масштабировать, tight coupling  | Традиционные приложения            |
| Hexagonal             | Тестируемость, изоляция ядра           | Сложность проектирования                | Backend с внешними интеграциями   |
| SOA                   | Централизованная интеграция            | Тяжеловесная, сложная эволюция         | Корпоративные интеграции           |
