---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/system-design/programming-patterns/"}
---

## Классические паттерны

### Factory (Фабрика)

**Кратко:**  
Создаёт объекты без указания конкретного класса.  
Используется для отделения логики создания объектов от их использования, облегчает расширение и тестирование.

**Типовой вопрос:**  
Зачем использовать фабрику вместо прямого вызова конструктора?

**Ответ:**  
- Скрывает сложную логику создания  
- Упрощает замену реализации  
- Позволяет расширять систему без изменения существующего кода  

```python
class ShapeFactory:
    def create(self, type: str):
        if type == "circle":
            return Circle()
        elif type == "square":
            return Square()
```

---

### Strategy (Стратегия)

**Кратко:**  
Инкапсулирует алгоритмы в отдельные классы и позволяет выбирать их во время выполнения.  
Уменьшает ветвления в коде.

**Типовой вопрос:**  
Почему strategy лучше, чем if/else?

**Ответ:**
- Алгоритмы изолированы
- Код расширяемый и тестируемый
- Поддерживается принцип открытости/закрытости (O из SOLID)

```python
class SortStrategy(Protocol):
    def sort(self, data: list[int]) -> list[int]: ...

class QuickSort(SortStrategy):
    def sort(self, data: list[int]) -> list[int]:
        return sorted(data)

class Context:
    def __init__(self, strategy: SortStrategy):
        self.strategy = strategy
```

---

### Adapter (Адаптер)

**Кратко:**  
Позволяет использовать несовместимые интерфейсы.  
Часто нужен при интеграции сторонних библиотек или смене интерфейса между слоями приложения.

**Типовой вопрос:**  
Когда adapter действительно необходим?

**Ответ:**
- Когда внешний API не подходит напрямую
- Когда нужно соблюсти интерфейс вашего приложения
- Когда нельзя менять стороннюю библиотеку

---

### Decorator (Декоратор)

**Кратко:**  
Динамически добавляет поведение объекту без изменения его класса.  
Применяется в Python через функции-декораторы или классы-обёртки.

**Типовой вопрос:**  
Почему decorator лучше наследования?

**Ответ:**
- Можно комбинировать поведение динамически
- Не создаёт сложную иерархию классов
- Упрощает поддержку и тестирование

```python
def log(func):
    def wrapper(*args, **kwargs):
        print("Call", func.__name__)
        return func(*args, **kwargs)
    return wrapper
```

---

## Паттерны уровня сервиса

### Circuit Breaker

**Кратко:**  
Защищает систему от лавины ошибок при сбоях внешних сервисов.  
Если сервис падает, circuit breaker временно блокирует вызовы.

Например, сервис оплаты обращается к внешнему шлюзу. Если шлюз недоступен, circuit breaker блокирует новые попытки на 30 секунд, возвращая клиенту заранее подготовленную ошибку. Это предотвращает накопление очередей и падение всего сервиса.

**Типовой вопрос:**  
Почему circuit breaker критичен для микросервисов?

**Ответ:**
- Предотвращает каскадные сбои
- Дает время сервису восстановиться
- Улучшает стабильность всей системы

---

### Bulkhead

**Кратко:**  
Изолирует ресурсы между компонентами системы.  
Позволяет сбою одного сервиса не влиять на другие.

Допустим, в системе уведомлений выделен отдельный пул потоков для email и отдельный для push-сообщений. Если сервис push падает или тормозит, email-сообщения продолжают доставляться без задержек, изоляция защищает критичные каналы.

**Типовой вопрос:**  
Когда bulkhead обязателен?

**Ответ:**
- Для фоновых задач с ограниченными ресурсами
- Для очередей и пулов соединений
- Для защиты критичных сервисов от перегрузки

---

### Retry

**Кратко:**  
Повторные попытки выполняются при временных ошибках.  
Должны сопровождаться backoff и лимитами.

Сервис интеграции с внешней CRM при сетевом сбое делает повторный запрос с экспоненциальным интервалом (backoff). Ограничение числа попыток предотвращает лавину запросов. Каждый запрос идемпотентен, чтобы повтор не создавал дубликатов данных.

**Типовой вопрос:**  
Почему retry без backoff опасен?

**Ответ:**
- Усиливает нагрузку на упавший сервис
- Может вызвать каскадный отказ
- Требует идемпотентности операций

---

### Rate Limiting

**Кратко:**  
Ограничивает частоту вызовов API или сервисов.  
Защищает систему и клиентов от перегрузки.

API публичного сервиса ограничивает 100 запросов в минуту на пользователя. Если клиент превышает лимит, получает ошибку 429. Это защищает сервис от перегрузки и гарантирует равномерное распределение ресурсов.

**Типовой вопрос:**  
Где лучше реализовывать rate limiting?

**Ответ:**
- На API Gateway
- На reverse proxy
- На уровне приложения  
    Алгоритмы: fixed window, sliding window, token bucket

---

### Saga

**Кратко:**  
Паттерн управления долгими бизнес-транзакциями через последовательность локальных транзакций с компенсацией при ошибках.

При заказе товара: сервис списания денег выполняет транзакцию, сервис складирования резервирует товар. Если склад не подтвердил резерв, выполняется компенсация — возврат денег клиенту. Saga позволяет координировать распределённые шаги без глобальных транзакций.

**Типовой вопрос:**  
Почему saga лучше распределённой транзакции?

**Ответ:**
- Нет глобальной блокировки ресурсов
- Подходит для микросервисов
- Позволяет согласованно откатывать шаги

---

### CQRS (Command-Query Responsibility Segregation)

**Кратко:**  
Разделяет операции чтения и записи.  
Используется для систем с высокой нагрузкой на чтение/запись.

Например, в системе соцсетей команды (posts, likes) обновляют отдельную модель записи, а запросы на отображение ленты используют оптимизированную модель для чтения. Такой подход позволяет масштабировать чтение отдельно от записи и снижает конкуренцию за ресурсы базы данных.

**Типовой вопрос:**  
Почему CQRS сложнее CRUD?

**Ответ:**
- Нужно поддерживать отдельные модели для чтения и записи
- Сложнее синхронизация
- Требует дополнительные механизмы согласованности

---

### Event Sourcing

**Кратко:**  
Состояние хранится как последовательность событий, а не snapshot.  
Позволяет восстанавливать историю, вести audit trail и реплеить события для новых моделей.

В финансовой системе каждое изменение баланса хранится как событие («депозит», «списание»). Состояние счёта восстанавливается, суммируя события, а не сохраняя текущий баланс. Это даёт полный audit trail и возможность воспроизвести состояние на любую дату или протестировать новые бизнес-правила на исторических событиях.

**Типовой вопрос:**  
Когда event sourcing оправдан?

**Ответ:**
- Для финансовых систем
- Для систем с audit trail
- Когда важна история изменений