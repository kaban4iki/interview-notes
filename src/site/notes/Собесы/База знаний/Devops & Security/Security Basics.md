---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/devops-and-security/security-basics/"}
---

## Аутентификация и Авторизация (AuthN & AuthZ)

**Кратко:** 
AuthN проверяет, кто вы (личность), а AuthZ — что вам разрешено делать (права). В современных системах стандартом являются протоколы OAuth2 и OpenID Connect (OIDC), работающие на базе JWT-токенов, которые позволяют передавать права доступа между микросервисами без постоянных запросов к центральной базе.

**Типовой вопрос:**  
В чем разница между RBAC и ABAC, и как безопасно отозвать JWT-токен до истечения его срока действия?

**Ответ:**  
- **RBAC (Role-Based):** Доступ на основе ролей (Admin, User). Просто, но негибко.
    
- **ABAC (Attribute-Based):** Доступ на основе атрибутов (время, IP, отдел). Сложнее, но позволяет реализовать логику «доступ только в рабочее время из офиса».
    
- **JWT Revocation:** Поскольку JWT самодостаточны (stateless), их нельзя просто удалить. Используются **Blacklists** (в Redis) для ID токенов или короткий срок жизни (TTL) для Access Token в связке с длинным Refresh Token.
    
- **Безопасность хранения:** Токены нельзя хранить в `localStorage` (уязвимы к XSS). На фронтенде их прячут в `HttpOnly, Secure` cookies.

---

## Защита API, Rate Limiting и Аудит

**Кратко:** 
Rate Limiting ограничивает количество запросов
Аудит и логирование обеспечивают «след» (Audit Trail), позволяющий понять, кто и когда изменил чувствительные данные.

**Типовой вопрос:**  
Как реализовать алгоритм Token Bucket для Rate Limiting и чем он отличается от Fixed Window?

**Ответ:**  
- **Token Bucket:** В «корзину» с постоянной скоростью капают токены. Запрос проходит, если токен есть. Это позволяет обрабатывать кратковременные всплески трафика (bursts).
- **Fixed Window:** Просто счетчик на интервал (например, 100 запросов в минуту). Опасен тем, что на границе минут можно пропустить 200 запросов сразу.

- **Аудит:** В логи безопасности (Audit Logs) нельзя писать PII-данные (пароли, номера карт). Логи должны быть неизменяемыми (WORM — Write Once, Read Many).

---

## Шифрование и управление секретами

**Кратко:** 
Безопасность данных делится на защиту «в покое» (At Rest) и «в движении» (In Transit). 

**Типовой вопрос:** 
Как работает TLS Handshake?

**Ответ:**
TLS Handshake — это процесс установки защищенного соединения между клиентом и сервером. Его задача: подтвердить подлинность сервера и согласовать общий секретный ключ для шифрования данных.

**Основные этапы:**
1. **Client Hello:** Клиент отправляет поддерживаемые версии TLS и список алгоритмов шифрования (cipher suites).
2. **Server Hello & Certificate:** Сервер выбирает алгоритм и отправляет свой **публичный сертификат**, подписанный доверенным центром (CA).
3. **Key Exchange:** Клиент проверяет сертификат. Затем генерируется временный секрет, который передается серверу.
4. **Symmetric Encryption:** Оба участника вычисляют общий **симметричный ключ** (Session Key). Теперь все данные шифруются им (например, через AES).
---

## OWASP Top 10 и безопасность кода

**Кратко:**  
Это рейтинг самых критических рисков безопасности веб-приложений. Для Python-разработчика ключевыми являются SQL-инъекции, некорректная десериализация и Broken Access Control.

**Типовой вопрос:**  
Как защититься от атаки **IDOR** (Insecure Direct Object Reference) в системе с миллионами пользователей, и почему стандартной проверки авторизации на уровне эндпоинта может быть недостаточно?»

**Ответ:**  
IDOR возникает, когда пользователь меняет ID в запросе (например, `GET /api/orders/100` на `1001`) и получает доступ к чужим данным.

**Методы защиты:**
- **Ownership Check (Проверка владения):** На каждом запросе в бизнес-логике (а не только в роутере) должен выполняться запрос к БД: `SELECT * FROM orders WHERE id = :id AND user_id = :current_user`. Если запись не найдена — возвращаем `404` (чтобы не подтверждать существование чужого ID) или `403`.
- **UUID вместо последовательных ID:** Использование случайных `UUID v4` делает перебор ID практически невозможным, в отличие от инкрементальных `1, 2, 3...`. Однако это лишь «маскировка», она не отменяет проверку прав.
- **Global Access Control Layer:** Использование паттерна **ACL** (Access Control List) или внешних политик (**OPA — Open Policy Agent**), где права проверяются централизованно перед выполнением любой операции с объектом.
- **HashID:** Внешние ID можно кодировать (например, библиотекой `hashids`), чтобы скрыть реальные значения первичных ключей базы данных от пользователя.

---

## DevSecOps (Security в CI/CD)

**Кратко:**  
Это подход «Shift Left Security» — перенос проверок безопасности на самые ранние этапы разработки. Безопасность не проверяется один раз перед релизом, а встроена в каждый коммит через автоматические инструменты.

**Типовой вопрос:**  
В чем разница между SAST и DAST и на каком этапе пайплайна их запускать?

**Ответ:**  
- **SAST (Static Analysis):** Анализ исходного кода без его запуска (например, **Bandit** для Python). Запускается в начале CI.
- **DAST (Dynamic Analysis):** Тестирование уже запущенного приложения на уязвимости (имитация атак). Запускается на Staging-окружении.
- **SCA (Software Composition Analysis):** Проверка зависимостей (библиотек из `requirements.txt`) на известные уязвимости (инструмент **Safety** или **Snyk**).

---

## Контейнерная и сетевая безопасность

**Кратко:**  
Основной принцип — минимизация поверхности атаки (Attack Surface) через изоляцию контейнеров и ограничение сетевых доступов по принципу «нулевого доверия» (Zero Trust).

**Типовой вопрос:**  
Почему запуск Docker-контейнера от пользователя root — это плохо, и что такое Network Policies в Kubernetes?

**Ответ:**  
- **Rootless containers:** Если злоумышленник взломает приложение внутри контейнера, запущенного от root, он может получить доступ к хостовой машине (Container Escape).
    
- **Distroless/Alpine:** Использование минимальных образов уменьшает количество предустановленных утилит, которыми может воспользоваться хакер.
    
- **Network Policies:** По умолчанию в K8s все поды могут общаться со всеми. Network Policies позволяют закрыть доступ (например, разрешить трафик к БД только из сервиса Backend).
