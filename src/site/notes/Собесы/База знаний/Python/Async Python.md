---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/python/async-python/"}
---

## Threads, Processes и AsyncIO

**Кратко:**  
Разные модели конкурентного выполнения.

**Процессы —** это отдельные программы, каждая со своей памятью, которые могут работать параллельно на разных ядрах процессора.
**Потоки —** это части одного процесса, которые одновременно выполняют задачи и используют для этого общую память.

**Типовой вопрос:**  
Когда использовать async, а когда потоки или процессы?

**Ответ:**  
Threads — I/O-bound задачи (для синхронизации можно использовать Lock, Semaphore, Event), обычно используются с легаси библиотеками, которые не поддерживают async/await синтаксис, или для реализации фоновых задач.  
Processes — CPU-bound задачи из-за GIL.
AsyncIO — позволяет выполнять задачи без блокировки основного потока, так как управляет задачами в одном потоке через цикл событий.

---

## Event Loop

**Кратко:**  
Event loop планирует и переключает корутины.

```python
import asyncio

async def main():
	await asyncio.sleep(1)

asyncio.run(main())
```

**Типовой вопрос:**  
Что делает event loop?

**Ответ:**  
Он управляет выполнением корутин и переключается между ними при `await`.

---

## `async` / `await`

**Кратко:**  
`async` создаёт корутину,  
`await` отдаёт управление event loop.

**Типовой вопрос:**  
Что будет, если забыть `await`?

**Ответ:**  
Вернётся coroutine object, код не выполнится и появится warning.

---

## Blocking code в async

**Кратко:**  
Блокирующий код останавливает event loop.

**Типовой вопрос:**  
Почему blocking код опасен в async?

**Ответ:**  
Он блокирует event loop и увеличивает время выполнения всего приложения.

---

## `create_task` vs `gather`

**Кратко:**  
`create_task` — планирует корутину,  
`gather` — ждёт несколько задач.

**Типовой вопрос:**  
Когда использовать `gather`?

**Ответ:**  
Когда нужно дождаться всех задач и собрать результат.