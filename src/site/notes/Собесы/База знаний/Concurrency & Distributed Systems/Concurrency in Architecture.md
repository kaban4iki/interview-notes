---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/concurrency-and-distributed-systems/concurrency-in-architecture/"}
---

## Конкурентность как архитектурное решение

**Кратко:**  
Конкурентность влияет на:
- сложность системы
- наблюдаемость
- стоимость поддержки
- надёжность

Выбор модели определяет долгосрочные последствия.

**Типовой вопрос:**  
Почему concurrency — архитектурный выбор?

**Ответ:**  
Потому что:
- смена модели требует переписывания кода
- влияет на инфраструктуру
- меняет профиль отказов

---

## Threading vs Async vs Separate Service

**Кратко:**  
Существует несколько способов масштабирования логики.

**Типовой вопрос:**  
Как выбрать модель конкурентности?

**Ответ:**  
- **Threads** — для блокирующих операций
- **Async** — для I/O и высокой конкурентности
- **Отдельный сервис** — для изоляции и масштабирования

Неправильный выбор увеличивает сложность.

---

## Очередь vs Прямой вызов

**Кратко:**  
Асинхронность часто реализуется через очереди.

**Типовой вопрос:**  
Когда очередь оправдана?

**Ответ:**  
Очередь нужна, если:
- результат не нужен сразу
- важна устойчивость
- нагрузка неравномерна

Для простых сценариев прямой вызов предпочтительнее.

---

## Latency vs Throughput

**Кратко:**  
Эти метрики часто конфликтуют.

**Типовой вопрос:**  
Почему нельзя оптимизировать всё сразу?

**Ответ:**  
Потому что:
- batching увеличивает throughput, но растит latency
- синхронизация снижает параллелизм
- ограничения ресурсов неизбежны

Приоритет определяется бизнесом.

---

## Backpressure как архитектурный механизм

**Кратко:**  
Backpressure ограничивает входящую нагрузку.

**Типовой вопрос:**  
Что происходит без backpressure?

**Ответ:**  
Без него:
- очереди растут бесконечно
- увеличивается latency
- система падает целиком

Backpressure стабилизирует систему.