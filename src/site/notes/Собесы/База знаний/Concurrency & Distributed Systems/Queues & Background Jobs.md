---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/concurrency-and-distributed-systems/queues-and-background-jobs/"}
---

## Очереди как архитектурный элемент

**Кратко:**  
Очереди используются для асинхронного взаимодействия между компонентами системы.  
Они отделяют приём запроса от выполнения работы и позволяют:
- сглаживать пиковую нагрузку
- повышать отказоустойчивость
- масштабировать обработку независимо

**Типовой вопрос:**  
Когда использование очереди оправдано, а когда это лишняя сложность?

**Ответ:**  
Очередь оправдана, если:
- работа занимает много времени
- важна устойчивость к сбоям
- требуется асинхронная обработка

Очередь — ошибка, если:
- нужен немедленный результат
- бизнес-логика проста
- задержка недопустима

---

## Гарантии доставки сообщений

**Кратко:**  
Очереди отличаются гарантиями доставки сообщений.  
Гарантии определяют, как система ведёт себя при сбоях.

**Типовой вопрос:**  
Чем отличаются at-most-once, at-least-once и exactly-once?

**Ответ:**  
- **At-most-once**  
  Сообщение доставляется не более одного раза.  
  Возможна потеря, дубликатов нет.
- **At-least-once**  
  Сообщение будет доставлено минимум один раз.  
  Возможны дубликаты, требуется идемпотентность consumer’а.
- **Exactly-once**  
  Сообщение обрабатывается ровно один раз.  
  Реализуется за счёт сложных механизмов и имеет высокую стоимость.

На практике чаще всего используется at-least-once.

---

## Idempotency consumer’ов

**Кратко:**  
Consumer должен корректно обрабатывать повторные сообщения.

**Типовой вопрос:**  
Почему идемпотентность важнее «идеальной» доставки?

**Ответ:**  
Потому что:
- сбои неизбежны
- exactly-once сложно и дорого
- дубликаты — нормальное явление

Типовые подходы:
- дедупликация по id сообщения
- уникальные ключи в БД
- проверка состояния перед выполнением

---

## Retry, DLQ и Poison Messages

**Кратко:**  
Ошибки обработки сообщений требуют отдельной стратегии.

**Типовой вопрос:**  
Как отличить временную ошибку от poison message?

**Ответ:**  
Временные ошибки:
- сетевые сбои
- таймауты
- перегрузка

Poison message:
- всегда приводит к ошибке
- ломает consumer при повторе

Решения:
- ограничение количества retry
- Dead Letter Queue
- ручной разбор проблемных сообщений

---

## Message Brokers — сравнительная таблица

**Кратко:**  
Message broker определяет модель доставки, масштабирование и эксплуатационную сложность.

**Типовой вопрос:**  
Как выбрать брокер под конкретную задачу?

**Ответ:**  
Выбор зависит от:
- требований к порядку сообщений
- объёма данных
- задержек
- операционной сложности

#### Сравнение брокеров сообщений

| Брокер        | Модель  | Порядок сообщений | Масштабирование | Сильные стороны          | Ограничения             | Типичные кейсы      |
| ------------- | ------- | ----------------- | --------------- | ------------------------ | ----------------------- | ------------------- |
| RabbitMQ      | Очереди | В рамках очереди  | Среднее         | Простота, маршрутизация  | Ограничен throughput    | Task queues         |
| Kafka         | Лог     | В рамках партиции | Высокое         | Большие объёмы, стриминг | Сложная эксплуатация    | Event streaming     |
| Redis Streams | Лог     | В рамках стрима   | Среднее         | Простота, Redis-стек     | Ограниченная надёжность | Lightweight очереди |

---

## Фоновые задачи

**Кратко:**  
Фоновые задачи выполняются вне жизненного цикла HTTP-запроса.  
Они используются для:
- отправки уведомлений
- обработки файлов
- интеграций
- периодических задач

**Типовой вопрос:**  
Почему нельзя выполнять фоновые задачи в HTTP обработчике?

**Ответ:**  
Потому что:
- увеличивается время ответа
- возрастает риск таймаутов
- сбои сложно обрабатывать

Фоновая задача должна быть изолирована от запроса.

---

## Task Queue системы — сравнительная таблица

**Кратко:**  
Task queue — это слой поверх брокера, управляющий выполнением задач.

**Типовой вопрос:**  
Как выбрать систему фоновых задач для Python?

**Ответ:**  
Выбор зависит от:
- сложности задач
- требований к масштабированию
- экосистемы проекта

#### Сравнение систем фоновых задач
| **Система**  | **Брокер**            | **Надёжность** | **Сложность** | **Сильные стороны**                                         | **Ограничения**                                    |
| ------------ | --------------------- | -------------- | ------------- | ----------------------------------------------------------- | -------------------------------------------------- |
| **Celery**   | RabbitMQ / Redis      | Высокая        | Высокая       | Огромная экосистема, сложные воркфлоу (chords, chains)      | Переусложнённый конфиг, плохая поддержка `asyncio` |
| **Taskiq**   | Redis / Rabbit / NATS | Высокая        | Средняя       | **Native Async**, типизация (PEP-612), DI (как в FastAPI)   | Молодая экосистема, только для `async` проектов    |
| **Dramatiq** | RabbitMQ / Redis      | Высокая        | Средняя       | Чистая архитектура, надежность «из коробки», малый overhead | Меньше плагинов, чем у Celery                      |
| **RQ**       | Redis                 | Средняя        | Низкая        | Минимальный порог входа, наглядность                        | Только Redis, нет сложных цепочек задач            |
