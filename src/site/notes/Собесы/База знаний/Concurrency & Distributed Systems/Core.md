---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/concurrency-and-distributed-systems/core/"}
---

## Concurrency vs Parallelism

**Кратко:**  
Concurrency — это способность системы работать с несколькими задачами, переключаясь между ними и управляя их выполнением.  
Parallelism — это одновременное выполнение нескольких задач физически, на разных ядрах CPU.  
Concurrency — про структуру программы и управление доступом к ресурсам, parallelism — про реальное одновременное выполнение.

**Типовой вопрос:**  
В чём разница между concurrency и parallelism и почему это важно при проектировании backend-систем?

**Ответ:**  
Concurrency позволяет системе эффективно использовать время ожидания (I/O, сеть, блокировки), даже если задачи не выполняются одновременно.  
Parallelism увеличивает вычислительную мощность за счёт нескольких ядер.  

На практике:
- IO-нагруженные системы выигрывают от concurrency
- CPU-нагруженные задачи требуют parallelism
- concurrency без правильной синхронизации приводит к ошибкам
- parallelism без контроля приводит к перерасходу ресурсов

---

## CPU-bound vs IO-bound задачи

**Кратко:**  
CPU-bound задачи ограничены скоростью процессора и количеством ядер.  
IO-bound задачи большую часть времени ожидают внешние операции: сеть, диск, БД.

Тип задачи определяет:
- модель конкурентности
- инструменты масштабирования
- эффективность потоков и асинхронности

**Типовой вопрос:**  
Почему для IO-bound задач часто выбирают асинхронную модель?

**Ответ:**  
Потому что асинхронность позволяет:
- не блокировать поток во время ожидания I/O
- обслуживать больше запросов меньшим числом потоков
- снизить накладные расходы на переключение контекста

Для CPU-bound задач асинхронность бесполезна без реального parallelism.

---

## Race Condition

**Кратко:**  
Race condition возникает, когда результат выполнения зависит от порядка выполнения конкурентных операций.  
Такие ошибки:
- трудно воспроизводимы
- зависят от нагрузки и таймингов
- часто проявляются только в продакшене

**Типовой вопрос:**  
Почему race condition сложно обнаружить тестами?

**Ответ:**  
Потому что:
- тесты выполняются в предсказуемых условиях
- планировщик потоков ведёт себя по-разному
- баг может проявляться только под высокой нагрузкой

Защита строится не тестами, а корректным дизайном:
- синхронизация
- изоляция данных
- неизменяемые структуры

---

## Deadlock, Livelock, Starvation

**Кратко:**  
Это классы ошибок конкурентного выполнения:

- **Deadlock** — взаимная блокировка ресурсов  
- **Livelock** — активная работа без прогресса  
- **Starvation** — задача не получает ресурсы достаточно долго  

**Типовой вопрос:**  
Чем deadlock отличается от livelock?

**Ответ:**  
Deadlock — система остановилась и не может продолжить работу.  
Livelock — система активно выполняется, но полезная работа не происходит.

Причины:
- неправильный порядок захвата блокировок
- слишком мелкие или слишком крупные критические секции
- отсутствие таймаутов

---

## Blocking vs Non-blocking модели

**Кратко:**  
Blocking модель останавливает выполнение до завершения операции.  
Non-blocking модель позволяет продолжить работу и получить результат позже.

Выбор модели влияет на:
- масштабируемость
- сложность кода
- требования к инфраструктуре

**Типовой вопрос:**  
Почему non-blocking модель сложнее в поддержке?

**Ответ:**  
Потому что:
- сложнее читать и отлаживать код
- ошибки проявляются асинхронно
- требуется строгая дисциплина работы с ресурсами

Non-blocking модель оправдана при высокой конкуренции и I/O-нагрузке.

---

## Backpressure

**Кратко:**  
Backpressure — механизм ограничения входящего потока данных, когда система не успевает обрабатывать нагрузку.  
Он защищает систему от перегрузки и деградации.

**Типовой вопрос:**  
Что происходит, если система не поддерживает backpressure?

**Ответ:**  
Без backpressure:
- растут очереди
- увеличивается latency
- потребляются все ресурсы
- система падает каскадно

Backpressure реализуется через:
- ограничение очередей
- отказ или замедление приёма запросов
- управление скоростью producer’ов

---

## Memory Visibility и Happens-Before

**Кратко:**  
Memory visibility определяет, когда изменения в памяти становятся видны другим потокам.  
Happens-before описывает гарантированный порядок операций между потоками.

**Типовой вопрос:**  
Почему синхронизация влияет не только на блокировки, но и на видимость данных?

**Ответ:**  
Потому что:
- CPU и компилятор могут переупорядочивать операции
- кэш процессора не сразу синхронизируется между ядрами

Блокировки и атомарные операции:
- ограничивают переупорядочивание
- гарантируют актуальность данных

---

## Thread Safety как свойство дизайна

**Кратко:**  
Thread safety — это свойство кода корректно работать при конкурентном доступе.  
Она не достигается добавлением блокировок постфактум.

**Типовой вопрос:**  
Почему thread safety — архитектурная задача, а не локальное исправление?

**Ответ:**  
Потому что:
- блокировки влияют на всю систему
- ошибки проектирования множатся с ростом кода
- проще изначально проектировать изоляцию и неизменяемость

Типовые подходы:
- ограничение области изменяемого состояния
- передача данных через сообщения
- минимизация общих ресурсов
