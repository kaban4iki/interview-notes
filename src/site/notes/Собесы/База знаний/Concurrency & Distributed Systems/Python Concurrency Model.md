---
{"dg-publish":true,"permalink":"/sobesy/baza-znanij/concurrency-and-distributed-systems/python-concurrency-model/"}
---

## GIL (Global Interpreter Lock)

**Кратко:**  
GIL — это глобальная блокировка в CPython, которая гарантирует, что байткод Python в один момент времени исполняется только одним потоком.  
GIL упрощает реализацию интерпретатора и управление памятью, но ограничивает масштабирование CPU-bound задач внутри одного процесса.

Важно:
- GIL не блокирует I/O
- GIL освобождается на системных вызовах
- GIL — особенность CPython, не языка Python

**Типовой вопрос:**  
Почему наличие GIL не делает Python «однопоточным»?

**Ответ:**  
Потому что:
- потоки существуют и переключаются
- I/O выполняется параллельно
- GIL защищает только выполнение байткода

Для IO-bound задач потоки масштабируются нормально.  
Для CPU-bound задач нужен multiprocessing или вынос вычислений.

---

## Потоки в Python (threading)

**Кратко:**  
Потоки в Python подходят для задач, где основное время тратится на ожидание: сеть, диск, внешние API.  
Они имеют общую память и требуют синхронизации.

**Типовой вопрос:**  
Когда использование потоков в Python оправдано?

**Ответ:**  
Потоки оправданы, если:
- задача IO-bound
- используется блокирующий код или библиотеки
- важна простота интеграции

Проблемы потоков:
- race condition
- сложная отладка
- блокировки влияют на весь процесс

---

## Multiprocessing

**Кратко:**  
Multiprocessing запускает несколько процессов с отдельной памятью.  
Это основной способ обойти GIL для CPU-bound задач.

**Типовой вопрос:**  
Почему multiprocessing сложнее, чем threading?

**Ответ:**  
Потому что:
- нет общей памяти
- требуется IPC
- выше накладные расходы

Зато:
- используется несколько ядер
- отсутствуют race condition на уровне памяти

---

## IPC (межпроцессное взаимодействие)

**Кратко:**  
IPC используется для обмена данными между процессами.

Основные механизмы:
- Queue
- Pipe
- shared memory
- sockets

**Типовой вопрос:**  
Почему IPC часто становится узким местом?

**Ответ:**  
Потому что:
- данные сериализуются
- копируются между процессами
- увеличивается latency

На практике IPC используют для передачи результатов, а не больших объёмов данных.

---

## Fork vs Spawn

**Кратко:**  
Это способы создания новых процессов.

- **fork** — копирует процесс (Unix)
- **spawn** — запускает новый интерпретатор (Windows, macOS по умолчанию)

**Типовой вопрос:**  
Почему код с multiprocessing ведёт себя по-разному на Windows и Linux?

**Ответ:**  
Потому что:
- fork наследует состояние процесса
- spawn требует явной инициализации

Следствия:
- необходимость `if __name__ == "__main__"`
- осторожность с глобальным состоянием

---

## Thread Safety стандартных структур

**Кратко:**  
Некоторые операции потокобезопасны, но это не гарантия корректности логики.

**Типовой вопрос:**  
Можно ли считать встроенные структуры данных Python thread-safe?

**Ответ:**  
Отдельные операции атомарны, но:
- последовательность операций — нет
- логическая целостность не гарантируется

Нельзя полагаться на GIL как на механизм синхронизации.

---

## Signal Handling

**Кратко:**  
Сигналы в Python обрабатываются только в основном потоке.

**Типовой вопрос:**  
Почему сигналы нельзя обрабатывать в рабочих потоках?

**Ответ:**  
Это ограничение интерпретатора:
- упрощает модель исполнения
- избегает гонок на уровне сигналов

Следствие — отдельная логика остановки и shutdown.

---

## Поведение под нагрузкой

**Кратко:**  
Под нагрузкой проблемы конкурентности проявляются быстрее.

**Типовой вопрос:**  
Какие ошибки Python-приложений чаще всего проявляются под нагрузкой?

**Ответ:**  
Частые проблемы:
- блокирующие вызовы в потоках
- истощение thread pool
- рост очередей
- утечки процессов

Нагрузочное тестирование обязательно для concurrency-кода.
